From b9686493ac8c500af404bdbb48ec6775ec5824b0 Mon Sep 17 00:00:00 2001
From: Alexander Scheel <ascheel@redhat.com>
Date: Sat, 8 Jul 2017 12:02:05 -0400
Subject: [PATCH 2/6] Implement gss_set_context_flags()

This commit implements gss_set_context_flags() in the
mechglue, krb5, iakerb, and spnego mechanisms.
---
 src/lib/gssapi/generic/gssapi_ext.h            |  7 ++++
 src/lib/gssapi/krb5/Makefile.in                |  3 ++
 src/lib/gssapi/krb5/gssapiP_krb5.h             | 15 ++++++++
 src/lib/gssapi/krb5/gssapi_krb5.c              |  2 ++
 src/lib/gssapi/krb5/iakerb.c                   | 18 ++++++++++
 src/lib/gssapi/krb5/set_context_flags.c        | 28 +++++++++++++++
 src/lib/gssapi/libgssapi_krb5.exports          |  1 +
 src/lib/gssapi/mechglue/Makefile.in            |  3 ++
 src/lib/gssapi/mechglue/g_accept_sec_context.c | 13 ++++++-
 src/lib/gssapi/mechglue/g_init_sec_context.c   | 15 ++++++++
 src/lib/gssapi/mechglue/g_initialize.c         |  2 ++
 src/lib/gssapi/mechglue/g_set_context_flags.c  | 40 +++++++++++++++++++++
 src/lib/gssapi/mechglue/mglueP.h               |  9 +++++
 src/lib/gssapi/spnego/gssapiP_spnego.h         | 10 ++++++
 src/lib/gssapi/spnego/spnego_mech.c            | 50 ++++++++++++++++++++++++++
 15 files changed, 215 insertions(+), 1 deletion(-)
 create mode 100644 src/lib/gssapi/krb5/set_context_flags.c
 create mode 100644 src/lib/gssapi/mechglue/g_set_context_flags.c

diff --git a/src/lib/gssapi/generic/gssapi_ext.h b/src/lib/gssapi/generic/gssapi_ext.h
index b327a75..f58c31d 100644
--- a/src/lib/gssapi/generic/gssapi_ext.h
+++ b/src/lib/gssapi/generic/gssapi_ext.h
@@ -582,6 +582,13 @@ gss_create_sec_context(
     OM_uint32 *,                /* minor_status */
     gss_ctx_id_t *);            /* context */
 
+OM_uint32 KRB5_CALLCONV
+gss_set_context_flags(
+    OM_uint32 *,                /* minor_status */
+    gss_ctx_id_t,               /* context */
+    uint64_t,                   /* req_flags */
+    uint64_t);                  /* ret_flags_understood */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/lib/gssapi/krb5/Makefile.in b/src/lib/gssapi/krb5/Makefile.in
index 1a10ab7..ac14a6d 100644
--- a/src/lib/gssapi/krb5/Makefile.in
+++ b/src/lib/gssapi/krb5/Makefile.in
@@ -74,6 +74,7 @@ SRCS = \
 	$(srcdir)/set_allowable_enctypes.c \
 	$(srcdir)/ser_sctx.c \
 	$(srcdir)/set_ccache.c \
+	$(srcdir)/set_context_flags.c \
 	$(srcdir)/store_cred.c \
 	$(srcdir)/util_cksum.c \
 	$(srcdir)/util_crypt.c \
@@ -128,6 +129,7 @@ OBJS = \
 	$(OUTPRE)set_allowable_enctypes.$(OBJEXT) \
 	$(OUTPRE)ser_sctx.$(OBJEXT) \
 	$(OUTPRE)set_ccache.$(OBJEXT) \
+	$(OUTPRE)set_context_flags.$(OBJEXT) \
 	$(OUTPRE)store_cred.$(OBJEXT) \
 	$(OUTPRE)util_cksum.$(OBJEXT) \
 	$(OUTPRE)util_crypt.$(OBJEXT) \
@@ -185,6 +187,7 @@ STLIBOBJS = \
 	set_allowable_enctypes.o \
 	ser_sctx.o \
 	set_ccache.o \
+	set_context_flags.o \
 	store_cred.o \
 	util_cksum.o \
 	util_crypt.o \
diff --git a/src/lib/gssapi/krb5/gssapiP_krb5.h b/src/lib/gssapi/krb5/gssapiP_krb5.h
index a36cbbb..9b59f34 100644
--- a/src/lib/gssapi/krb5/gssapiP_krb5.h
+++ b/src/lib/gssapi/krb5/gssapiP_krb5.h
@@ -247,6 +247,8 @@ typedef struct _krb5_gss_ctx_id_rec {
     krb5_cksumtype acceptor_subkey_cksumtype;
     int cred_rcache;             /* did we get rcache from creds? */
     krb5_authdata **authdata;
+    uint64_t req_flags;
+    uint64_t ret_flags_understood;
 } krb5_gss_ctx_id_rec, *krb5_gss_ctx_id_t;
 
 extern g_set kg_vdb;
@@ -630,6 +632,13 @@ OM_uint32 KRB5_CALLCONV krb5_gss_create_sec_context
  gss_ctx_id_t*      /* context */
 );
 
+OM_uint32 KRB5_CALLCONV krb5_gss_set_context_flags
+(OM_uint32*,        /* minor_status */
+ gss_ctx_id_t,      /* context */
+ uint64_t,          /* req_flags */
+ uint64_t           /* ret_flags_understood */
+);
+
 OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid
 (OM_uint32*,       /* minor_status */
  const gss_ctx_id_t,
@@ -1434,6 +1443,12 @@ OM_uint32 KRB5_CALLCONV
 iakerb_gss_create_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle);
 
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_set_context_flags(OM_uint32 *minor_status,
+                             gss_ctx_id_t context_handle,
+                             uint64_t req_flags,
+                             uint64_t ret_flags_understood);
+
 /* Magic string to identify exported krb5 GSS credentials.  Increment this if
  * the format changes. */
 #define CRED_EXPORT_MAGIC "K5C1"
diff --git a/src/lib/gssapi/krb5/gssapi_krb5.c b/src/lib/gssapi/krb5/gssapi_krb5.c
index 49d1228..2197cb5 100644
--- a/src/lib/gssapi/krb5/gssapi_krb5.c
+++ b/src/lib/gssapi/krb5/gssapi_krb5.c
@@ -932,6 +932,7 @@ static struct gss_config krb5_mechanism = {
     krb5_gss_verify_mic_iov,
     krb5_gss_get_mic_iov_length,
     krb5_gss_create_sec_context,
+    krb5_gss_set_context_flags
 };
 
 /* Functions which use security contexts or acquire creds are IAKERB-specific;
@@ -1025,6 +1026,7 @@ static struct gss_config iakerb_mechanism = {
     iakerb_gss_verify_mic_iov,
     iakerb_gss_get_mic_iov_length,
     iakerb_gss_create_sec_context,
+    iakerb_gss_set_context_flags
 };
 
 #ifdef _GSS_STATIC_LINK
diff --git a/src/lib/gssapi/krb5/iakerb.c b/src/lib/gssapi/krb5/iakerb.c
index 2347744..19fc392 100644
--- a/src/lib/gssapi/krb5/iakerb.c
+++ b/src/lib/gssapi/krb5/iakerb.c
@@ -799,6 +799,24 @@ iakerb_gss_create_sec_context(OM_uint32 *minor_status,
 }
 
 OM_uint32 KRB5_CALLCONV
+iakerb_gss_set_context_flags(OM_uint32 *minor_status,
+                             gss_ctx_id_t context_handle,
+                             uint64_t req_flags,
+                             uint64_t ret_flags_understood)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx == NULL || ctx->gssc == NULL) {
+        if (minor_status != NULL)
+            *minor_status = 0;
+        return GSS_S_FAILURE | GSS_S_NO_CONTEXT;
+    }
+
+    return krb5_gss_set_context_flags(minor_status, ctx->gssc, req_flags,
+                                      ret_flags_understood);
+}
+
+OM_uint32 KRB5_CALLCONV
 iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_cred_id_t verifier_cred_handle,
diff --git a/src/lib/gssapi/krb5/set_context_flags.c b/src/lib/gssapi/krb5/set_context_flags.c
new file mode 100644
index 0000000..2daf63b
--- /dev/null
+++ b/src/lib/gssapi/krb5/set_context_flags.c
@@ -0,0 +1,28 @@
+/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+
+#include "k5-int.h"
+#include "gssapiP_krb5.h"
+
+#include <stdlib.h>
+
+OM_uint32 KRB5_CALLCONV
+krb5_gss_set_context_flags(OM_uint32 *minor_status, gss_ctx_id_t context,
+                           uint64_t req_flags, uint64_t ret_flags_understood)
+{
+    krb5_gss_ctx_id_t ctx;
+
+    if (context == GSS_C_NO_CONTEXT)
+        return GSS_S_FAILURE | GSS_S_NO_CONTEXT;
+
+    if (minor_status != NULL)
+        *minor_status = 0;
+
+    ctx = (krb5_gss_ctx_id_t)context;
+    if (ctx->magic != KG_CONTEXT)
+        return GSS_S_FAILURE | GSS_S_NO_CONTEXT;
+
+    ctx->req_flags = req_flags;
+    ctx->ret_flags_understood = ret_flags_understood;
+
+    return GSS_S_COMPLETE;
+}
diff --git a/src/lib/gssapi/libgssapi_krb5.exports b/src/lib/gssapi/libgssapi_krb5.exports
index 8202486..66ad7ad 100644
--- a/src/lib/gssapi/libgssapi_krb5.exports
+++ b/src/lib/gssapi/libgssapi_krb5.exports
@@ -130,6 +130,7 @@ gss_release_name
 gss_release_oid
 gss_release_oid_set
 gss_seal
+gss_set_context_flags
 gss_set_name_attribute
 gss_set_neg_mechs
 gss_set_sec_context_option
diff --git a/src/lib/gssapi/mechglue/Makefile.in b/src/lib/gssapi/mechglue/Makefile.in
index 543a03e..4e11afb 100644
--- a/src/lib/gssapi/mechglue/Makefile.in
+++ b/src/lib/gssapi/mechglue/Makefile.in
@@ -60,6 +60,7 @@ SRCS = \
 	$(srcdir)/g_rel_oid_set.c \
 	$(srcdir)/g_saslname.c \
 	$(srcdir)/g_seal.c \
+	$(srcdir)/g_set_context_flags.c \
 	$(srcdir)/g_set_context_option.c \
 	$(srcdir)/g_set_cred_option.c \
 	$(srcdir)/g_set_name_attr.c \
@@ -125,6 +126,7 @@ OBJS = \
 	$(OUTPRE)g_rel_oid_set.$(OBJEXT) \
 	$(OUTPRE)g_saslname.$(OBJEXT) \
 	$(OUTPRE)g_seal.$(OBJEXT) \
+	$(OUTPRE)g_set_context_flags.$(OBJEXT) \
 	$(OUTPRE)g_set_context_option.$(OBJEXT) \
 	$(OUTPRE)g_set_cred_option.$(OBJEXT) \
 	$(OUTPRE)g_set_name_attr.$(OBJEXT) \
@@ -190,6 +192,7 @@ STLIBOBJS = \
 	g_rel_oid_set.o \
 	g_saslname.o \
 	g_seal.o \
+	g_set_context_flags.o \
 	g_set_context_option.o \
 	g_set_cred_option.o \
 	g_set_name_attr.o \
diff --git a/src/lib/gssapi/mechglue/g_accept_sec_context.c b/src/lib/gssapi/mechglue/g_accept_sec_context.c
index 70c2733..f147249 100644
--- a/src/lib/gssapi/mechglue/g_accept_sec_context.c
+++ b/src/lib/gssapi/mechglue/g_accept_sec_context.c
@@ -253,6 +253,18 @@ gss_cred_id_t *		d_cred;
 	    if (status != GSS_S_COMPLETE)
 		goto error_out;
 	}
+
+	if (mech->gss_set_context_flags != NULL &&
+	    (union_ctx_id->req_flags != 0 ||
+	    union_ctx_id->ret_flags_understood != 0)) {
+	    status = mech->gss_set_context_flags(
+	        &temp_minor_status,
+	        union_ctx_id->internal_ctx_id,
+	        union_ctx_id->req_flags,
+	        union_ctx_id->ret_flags_understood);
+	    if (status != GSS_S_COMPLETE)
+		return status;
+	}
     }
 
     /*
@@ -404,7 +416,6 @@ error_out:
     if (tmp_src_name != GSS_C_NO_NAME)
 	(void) gss_release_buffer(&temp_minor_status,
 				  (gss_buffer_t)tmp_src_name);
-
     return (status);
 }
 #endif /* LEAN_CLIENT */
diff --git a/src/lib/gssapi/mechglue/g_init_sec_context.c b/src/lib/gssapi/mechglue/g_init_sec_context.c
index 509b936..8e87ce9 100644
--- a/src/lib/gssapi/mechglue/g_init_sec_context.c
+++ b/src/lib/gssapi/mechglue/g_init_sec_context.c
@@ -204,8 +204,23 @@ OM_uint32 *		time_rec;
 	    if (status != GSS_S_COMPLETE)
 		goto end;
 	}
+
+	if (mech->gss_set_context_flags != NULL &&
+            (union_ctx_id->req_flags != 0 ||
+            union_ctx_id->ret_flags_understood != 0)) {
+	    status = mech->gss_set_context_flags(
+	        &temp_minor_status,
+	        union_ctx_id->internal_ctx_id,
+	        union_ctx_id->req_flags,
+	        union_ctx_id->ret_flags_understood);
+	    if (status != GSS_S_COMPLETE)
+	        goto end;
+	}
     }
 
+    if (req_flags == 0)
+	req_flags = union_ctx_id->req_flags;
+
     /*
      * get the appropriate cred handle from the union cred struct.
      * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will
diff --git a/src/lib/gssapi/mechglue/g_initialize.c b/src/lib/gssapi/mechglue/g_initialize.c
index 815d00b..42d66db 100644
--- a/src/lib/gssapi/mechglue/g_initialize.c
+++ b/src/lib/gssapi/mechglue/g_initialize.c
@@ -765,6 +765,7 @@ build_dynamicMech(void *dl, const gss_OID mech_type)
 	GSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_import_cred_by_mech);
 	/* draft-ietf-kitten-channel-bound-flag */
 	GSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_create_sec_context);
+	GSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_set_context_flags);
 
 	assert(mech_type != GSS_C_NO_OID);
 
@@ -871,6 +872,7 @@ build_interMech(void *dl, const gss_OID mech_type)
 	RESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _import_cred_by_mech);
 	/* draft-ietf-kitten-channel-bound-flag */
 	RESOLVE_GSSI_SYMBOL(dl, mech, gss, _create_sec_context);
+	RESOLVE_GSSI_SYMBOL(dl, mech, gss, _set_context_flags);
 
 	mech->mech_type = *mech_type;
 	return mech;
diff --git a/src/lib/gssapi/mechglue/g_set_context_flags.c b/src/lib/gssapi/mechglue/g_set_context_flags.c
new file mode 100644
index 0000000..a4f592b
--- /dev/null
+++ b/src/lib/gssapi/mechglue/g_set_context_flags.c
@@ -0,0 +1,40 @@
+/* #pragma ident	                                                    */
+
+/*
+ *  glue routine for gss_set_context_flags
+ */
+
+#include "mglueP.h"
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#include <string.h>
+#include <errno.h>
+#include <time.h>
+
+/*
+ * Defined:
+ * https://tools.ietf.org/html/draft-ietf-kitten-channel-bound-flag-01
+ *
+ * Section 2.2
+ *
+ * See src/lib/gssapi/generic/gssapi_ext.h for type definitions.
+ */
+OM_uint32 KRB5_CALLCONV
+gss_set_context_flags(OM_uint32 *minor_status, gss_ctx_id_t context,
+                      uint64_t req_flags, uint64_t ret_flags_understood)
+{
+    gss_union_ctx_id_t union_ctx;
+
+    if (context == NULL)
+        return GSS_S_FAILURE;
+
+    union_ctx = (gss_union_ctx_id_t)context;
+    if (GSSINT_CHK_LOOP(union_ctx))
+        return GSS_S_FAILURE;
+
+    union_ctx->req_flags = req_flags;
+    union_ctx->ret_flags_understood = ret_flags_understood;
+
+    return GSS_S_COMPLETE;
+}
diff --git a/src/lib/gssapi/mechglue/mglueP.h b/src/lib/gssapi/mechglue/mglueP.h
index 2c8232c..a29cf43 100644
--- a/src/lib/gssapi/mechglue/mglueP.h
+++ b/src/lib/gssapi/mechglue/mglueP.h
@@ -27,6 +27,8 @@ typedef struct gss_union_ctx_id_struct {
 	struct gss_union_ctx_id_struct *loopback;
 	gss_OID			mech_type;
 	gss_ctx_id_t		internal_ctx_id;
+	uint64_t		req_flags;
+	uint64_t		ret_flags_understood;
 } gss_union_ctx_id_desc, *gss_union_ctx_id_t;
 
 /*
@@ -711,6 +713,13 @@ typedef struct gss_config {
 	    gss_ctx_id_t *              /* context */
 	);
 
+	OM_uint32       (KRB5_CALLCONV *gss_set_context_flags)
+	(
+	    OM_uint32 *,                /* minor_status */
+	    gss_ctx_id_t,               /* context */
+	    uint64_t,                   /* req_flags */
+	    uint64_t                    /* ret_flags */
+	);
 } *gss_mechanism;
 
 /*
diff --git a/src/lib/gssapi/spnego/gssapiP_spnego.h b/src/lib/gssapi/spnego/gssapiP_spnego.h
index 8103b85..d1be769 100644
--- a/src/lib/gssapi/spnego/gssapiP_spnego.h
+++ b/src/lib/gssapi/spnego/gssapiP_spnego.h
@@ -110,6 +110,8 @@ typedef struct {
 	OM_uint32 ctx_flags;
 	gss_name_t internal_name;
 	gss_OID actual_mech;
+	uint64_t req_flags;
+	uint64_t ret_flags_understood;
 } spnego_gss_ctx_id_rec, *spnego_gss_ctx_id_t;
 
 /*
@@ -667,6 +669,14 @@ spnego_gss_create_sec_context(
 	gss_ctx_id_t *context
 );
 
+OM_uint32 KRB5_CALLCONV
+spnego_gss_set_context_flags(
+	OM_uint32 *minor_status,
+	gss_ctx_id_t context,
+	uint64_t req_flags,
+	uint64_t ret_flags_understood
+);
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/src/lib/gssapi/spnego/spnego_mech.c b/src/lib/gssapi/spnego/spnego_mech.c
index 2359daf..eb9070a 100644
--- a/src/lib/gssapi/spnego/spnego_mech.c
+++ b/src/lib/gssapi/spnego/spnego_mech.c
@@ -283,6 +283,7 @@ static struct gss_config spnego_mechanism =
 	spnego_gss_verify_mic_iov,
 	spnego_gss_get_mic_iov_length,
 	spnego_gss_create_sec_context,
+	spnego_gss_set_context_flags
 };
 
 #ifdef _GSS_STATIC_LINK
@@ -911,6 +912,19 @@ init_ctx_call_init(OM_uint32 *minor_status,
 		ret = gss_create_sec_context(minor_status, &sc->ctx_handle);
 		if (ret != GSS_S_COMPLETE)
 			return ret;
+
+		if (sc->req_flags != 0 || sc->ret_flags_understood != 0) {
+			ret = gss_set_context_flags(minor_status,
+			                            sc->ctx_handle,
+			                            sc->req_flags,
+			                            sc->ret_flags_understood);
+			if (ret != GSS_S_COMPLETE) {
+				gss_delete_sec_context(minor_status,
+				                       &sc->ctx_handle,
+				                       GSS_C_NO_BUFFER);
+				return ret;
+			}
+		}
 	}
 
 	ret = gss_init_sec_context(minor_status,
@@ -1553,6 +1567,19 @@ acc_ctx_call_acc(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
 		ret = gss_create_sec_context(minor_status, &sc->ctx_handle);
 		if (ret != GSS_S_COMPLETE)
 			return ret;
+
+		if (sc->req_flags != 0 || sc->ret_flags_understood != 0) {
+			ret = gss_set_context_flags(minor_status,
+			                            sc->ctx_handle,
+			                            sc->req_flags,
+			                            sc->ret_flags_understood);
+			if (ret != GSS_S_COMPLETE) {
+				gss_delete_sec_context(minor_status,
+				                       &sc->ctx_handle,
+				                       GSS_C_NO_BUFFER);
+				return ret;
+			}
+		}
 	}
 
 	mcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;
@@ -3059,6 +3086,29 @@ spnego_gss_create_sec_context(OM_uint32 *minor_status,
 	return GSS_S_COMPLETE;
 }
 
+OM_uint32 KRB5_CALLCONV
+spnego_gss_set_context_flags(OM_uint32 *minor_status,
+                             gss_ctx_id_t context,
+                             uint64_t req_flags,
+                             uint64_t ret_flags_understood)
+{
+	spnego_gss_ctx_id_t ctx;
+
+	if (context == GSS_C_NO_CONTEXT) {
+		return GSS_S_FAILURE | GSS_S_NO_CONTEXT;
+	}
+
+	ctx = (spnego_gss_ctx_id_t)context;
+	if (ctx->magic_num != SPNEGO_MAGIC_ID) {
+		return GSS_S_FAILURE | GSS_S_NO_CONTEXT;
+	}
+
+	ctx->req_flags = req_flags;
+	ctx->ret_flags_understood = ret_flags_understood;
+
+	return GSS_S_COMPLETE;
+}
+
 /*
  * We will release everything but the ctx_handle so that it
  * can be passed back to init/accept context. This routine should
-- 
2.9.4

